(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('lodash'), require('js-sha3'), require('flatley'), require('ajv'), require('verbal-expressions'), require('validator'), require('uuid')) :
	typeof define === 'function' && define.amd ? define(['exports', 'lodash', 'js-sha3', 'flatley', 'ajv', 'verbal-expressions', 'validator', 'uuid'], factory) :
	(global = global || self, factory(global.openAttestation = {}, global.lodash, global.jsSha3, global.flatley, global.ajv, global.verbalExpressions, global.validator, global.uuid));
}(this, function (exports, lodash, jsSha3, flatley, ajv, verbalExpressions, validator, uuid) { 'use strict';

	lodash = lodash && lodash.hasOwnProperty('default') ? lodash['default'] : lodash;
	jsSha3 = jsSha3 && jsSha3.hasOwnProperty('default') ? jsSha3['default'] : jsSha3;
	flatley = flatley && flatley.hasOwnProperty('default') ? flatley['default'] : flatley;
	ajv = ajv && ajv.hasOwnProperty('default') ? ajv['default'] : ajv;
	verbalExpressions = verbalExpressions && verbalExpressions.hasOwnProperty('default') ? verbalExpressions['default'] : verbalExpressions;
	validator = validator && validator.hasOwnProperty('default') ? validator['default'] : validator;
	uuid = uuid && uuid.hasOwnProperty('default') ? uuid['default'] : uuid;

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var flatten = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });


	var hasPeriodInKey = function (key) {
	    if (key.indexOf(".") >= 0) {
	        throw new Error("Key names must not have . in them");
	    }
	    return false;
	};
	var filters = [{ test: hasPeriodInKey }];
	/**
	 * Calls external flatten library but ensures that global filters are always applied
	 * @param data
	 * @param options
	 */
	exports.flatten = function (data, options) {
	    var _a;
	    var newOptions = options ? lodash.cloneDeep(options) : {};
	    if (newOptions.coercion) {
	        (_a = newOptions.coercion).push.apply(_a, filters);
	    }
	    else {
	        newOptions.coercion = filters;
	    }
	    return flatley.flatten(data, newOptions);
	};
	});

	unwrapExports(flatten);
	var flatten_1 = flatten.flatten;

	var digest = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	var isKeyOrValueUndefined = function (value, key) { return value === undefined || key === undefined; };
	exports.flattenHashArray = function (data) {
	    var flattenedData = lodash.omitBy(flatten.flatten(data), isKeyOrValueUndefined);
	    return Object.keys(flattenedData).map(function (k) {
	        var obj = {};
	        obj[k] = flattenedData[k];
	        return jsSha3.keccak256(JSON.stringify(obj));
	    });
	};
	exports.digestDocument = function (document) {
	    // Prepare array of hashes from filtered data
	    var hashedDataArray = lodash.get(document, "privacy.obfuscatedData", []);
	    // Prepare array of hashes from visible data
	    var unhashedData = lodash.get(document, "data");
	    var hashedUnhashedDataArray = exports.flattenHashArray(unhashedData);
	    // Combine both array and sort them to ensure determinism
	    var combinedHashes = hashedDataArray.concat(hashedUnhashedDataArray);
	    var sortedHashes = lodash.sortBy(combinedHashes);
	    // Finally, return the digest of the entire set of data
	    return jsSha3.keccak256(JSON.stringify(sortedHashes));
	};
	});

	unwrapExports(digest);
	var digest_1 = digest.flattenHashArray;
	var digest_2 = digest.digestDocument;

	var digest$1 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(digest);
	});

	unwrapExports(digest$1);

	var utils = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	/**
	 * Sorts the given Buffers lexicographically and then concatenates them to form one continuous Buffer
	 */
	function bufSortJoin() {
	    var args = [];
	    for (var _i = 0; _i < arguments.length; _i++) {
	        args[_i] = arguments[_i];
	    }
	    return Buffer.concat(args.slice().sort(Buffer.compare));
	}
	exports.bufSortJoin = bufSortJoin;
	// If hash is not a buffer, convert it to buffer (without hashing it)
	function hashToBuffer(hash) {
	    // @ts-ignore https://github.com/Microsoft/TypeScript/issues/23155
	    return Buffer.isBuffer(hash) && hash.length === 32 ? hash : Buffer.from(hash, "hex");
	}
	exports.hashToBuffer = hashToBuffer;
	// If element is not a buffer, stringify it and then hash it to be a buffer
	function toBuffer(element) {
	    return Buffer.isBuffer(element) && element.length === 32 ? element : hashToBuffer(jsSha3.keccak256(JSON.stringify(element)));
	}
	exports.toBuffer = toBuffer;
	/**
	 * Turns array of data into sorted array of hashes
	 */
	function hashArray(arr) {
	    return arr.map(function (i) { return toBuffer(i); }).sort(Buffer.compare);
	}
	exports.hashArray = hashArray;
	/**
	 * Returns the keccak hash of two buffers after concatenating them and sorting them
	 * If either hash is not given, the input is returned
	 */
	function combineHashBuffers(first, second) {
	    if (!second) {
	        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	        return first; // it should always be valued if second is not
	    }
	    if (!first) {
	        return second;
	    }
	    return hashToBuffer(jsSha3.keccak256(bufSortJoin(first, second)));
	}
	exports.combineHashBuffers = combineHashBuffers;
	/**
	 * Returns the keccak hash of two string after concatenating them and sorting them
	 * If either hash is not given, the input is returned
	 * @param first A string to be hashed (without 0x)
	 * @param second A string to be hashed (without 0x)
	 * @returns Resulting string after the hash is combined (without 0x)
	 */
	function combineHashString(first, second) {
	    return first && second
	        ? combineHashBuffers(hashToBuffer(first), hashToBuffer(second)).toString("hex")
	        : // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	            (first || second); // this should always return a value right ? :)
	}
	exports.combineHashString = combineHashString;
	});

	unwrapExports(utils);
	var utils_1 = utils.bufSortJoin;
	var utils_2 = utils.hashToBuffer;
	var utils_3 = utils.toBuffer;
	var utils_4 = utils.hashArray;
	var utils_5 = utils.combineHashBuffers;
	var utils_6 = utils.combineHashString;

	var regex = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	var hexDigits = verbalExpressions().range("0", "9", "a", "f", "A", "F");
	var hexString = verbalExpressions()
	    .then("0x")
	    .then(hexDigits)
	    .oneOrMore();
	exports.isHexString = function (input) {
	    var testRegex = verbalExpressions()
	        .startOfLine()
	        .then(hexString)
	        .endOfLine();
	    return testRegex.test(input);
	};
	});

	unwrapExports(regex);
	var regex_1 = regex.isHexString;

	var utils$1 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(utils);
	__export(regex);
	});

	unwrapExports(utils$1);

	var salt = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });



	var UUIDV4_LENGTH = 37;
	var PRIMITIVE_TYPES = ["string", "number", "boolean", "undefined"];
	/* eslint-disable no-use-before-define */
	/**
	 * Curried function that takes (iteratee)(value),
	 * if value is a collection then recurse into it
	 * otherwise apply `iteratee` on the primitive value
	 */
	var recursivelyApply = function (iteratee) { return function (value) {
	    if (lodash.includes(PRIMITIVE_TYPES, typeof value) || value === null) {
	        return iteratee(value);
	    }
	    return exports.deepMap(value, iteratee); // eslint-disable-line @typescript-eslint/no-use-before-define
	}; };
	/**
	 * Applies `iteratee` to all fields in objects, goes into arrays as well.
	 * Refer to test for example
	 */
	exports.deepMap = function (collection, iteratee) {
	    if (iteratee === void 0) { iteratee = lodash.identity; }
	    if (collection instanceof Array) {
	        return lodash.map(collection, recursivelyApply(iteratee));
	    }
	    if (typeof collection === "object") {
	        return lodash.mapValues(collection, recursivelyApply(iteratee));
	    }
	    return collection;
	};
	/* eslint-enable no-use-before-define */
	// disabling this because of mutual recursion
	var startsWithUuidV4 = function (input) {
	    if (input && typeof input === "string") {
	        var elements = input.split(":");
	        return validator.isUUID(elements[0], 4);
	    }
	    return false;
	};
	/**
	 * Detects the type of a value and returns a string with type annotation
	 */
	function primitiveToTypedString(value) {
	    switch (typeof value) {
	        case "number":
	        case "string":
	        case "boolean":
	        case "undefined":
	            return typeof value + ":" + String(value);
	        default:
	            if (value === null) {
	                // typeof null is 'object' so we have to check for it
	                return "null:null";
	            }
	            throw new Error("Parsing error, value is not of primitive type: " + value);
	    }
	}
	exports.primitiveToTypedString = primitiveToTypedString;
	/**
	 * Returns an appropriately typed value given a string with type annotations, e.g: "number:5"
	 */
	function typedStringToPrimitive(input) {
	    var _a = input.split(":"), type = _a[0], valueArray = _a.slice(1);
	    var value = valueArray.join(":"); // just in case there are colons in the value
	    switch (type) {
	        case "number":
	            return Number(value);
	        case "string":
	            return String(value);
	        case "boolean":
	            return value === "true";
	        case "null":
	            return null;
	        case "undefined":
	            return undefined;
	        default:
	            throw new Error("Parsing error, type annotation not found in string: " + input);
	    }
	}
	exports.typedStringToPrimitive = typedStringToPrimitive;
	/**
	 * Returns a salted value using a randomly generated uuidv4 string for salt
	 */
	function uuidSalt(value) {
	    var salt = uuid.v4();
	    return salt + ":" + primitiveToTypedString(value);
	}
	exports.uuidSalt = uuidSalt;
	/**
	 * Value salted string in the format "salt:type:value", example: "ee7f3323-1634-4dea-8c12-f0bb83aff874:number:5"
	 * Returns an appropriately typed value when given a salted string with type annotation
	 */
	function unsalt(value) {
	    if (startsWithUuidV4(value)) {
	        var untypedValue = value.substring(UUIDV4_LENGTH).trim();
	        return typedStringToPrimitive(untypedValue);
	    }
	    return value;
	}
	exports.unsalt = unsalt;
	// Use uuid salting method to recursively salt data
	exports.saltData = function (data) { return exports.deepMap(data, uuidSalt); };
	exports.unsaltData = function (data) { return exports.deepMap(data, unsalt); };
	});

	unwrapExports(salt);
	var salt_1 = salt.deepMap;
	var salt_2 = salt.primitiveToTypedString;
	var salt_3 = salt.typedStringToPrimitive;
	var salt_4 = salt.uuidSalt;
	var salt_5 = salt.unsalt;
	var salt_6 = salt.saltData;
	var salt_7 = salt.unsaltData;

	var salt$1 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(salt);
	});

	unwrapExports(salt$1);

	var privacy = createCommonjsModule(function (module, exports) {
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });




	exports.getData = function (document) { return salt$1.unsaltData(document.data); };
	/**
	 * Takes a partial originating document, possibly only with a schema.id and returns a document with the given data and obfuscated data
	 * @param document the metadata container
	 * @param data the data
	 * @param obfuscatedData hashes of replaced data to put into the privacy field
	 */
	// TODO: split into two separate functions for the two different use cases
	exports.setData = function (document, data, obfuscatedData) {
	    if (obfuscatedData === void 0) { obfuscatedData = []; }
	    var privacy = __assign({}, document.privacy, { obfuscatedData: obfuscatedData && obfuscatedData.length > 0 ? obfuscatedData : [] });
	    return __assign({}, document, { data: data,
	        privacy: privacy });
	};
	exports.obfuscateData = function (_data, fields) {
	    var data = lodash.cloneDeep(_data); // Prevents alteration of original data
	    var fieldsToRemove = Array.isArray(fields) ? fields : [fields];
	    // Obfuscate data by hashing them with the key
	    var dataToObfuscate = flatten.flatten(lodash.pick(data, fieldsToRemove));
	    var obfuscatedData = Object.keys(dataToObfuscate).map(function (k) {
	        var obj = {};
	        obj[k] = dataToObfuscate[k];
	        return utils$1.toBuffer(obj).toString("hex");
	    });
	    // Return remaining data
	    fieldsToRemove.forEach(function (path) {
	        lodash.unset(data, path);
	    });
	    return {
	        data: data,
	        obfuscatedData: obfuscatedData
	    };
	};
	exports.obfuscateDocument = function (document, fields) {
	    var existingData = document.data;
	    var _a = exports.obfuscateData(existingData, fields), data = _a.data, obfuscatedData = _a.obfuscatedData;
	    // we use lodash.get because document might not have the correct fields when coming from external input
	    var currentObfuscatedData = lodash.get(document, "privacy.obfuscatedData", []);
	    var newObfuscatedData = currentObfuscatedData.concat(obfuscatedData);
	    return exports.setData(document, data, newObfuscatedData);
	};
	});

	unwrapExports(privacy);
	var privacy_1 = privacy.getData;
	var privacy_2 = privacy.setData;
	var privacy_3 = privacy.obfuscateData;
	var privacy_4 = privacy.obfuscateDocument;

	var privacy$1 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(privacy);
	});

	unwrapExports(privacy$1);

	var schema = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });


	// We need to do this horrible thing because the return type of validate makes no sense
	// https://github.com/epoberezkin/ajv/issues/911
	var ajv$1 = new ajv();
	exports.addSchema = function (schema) {
	    try {
	        ajv$1.addSchema(schema, schema.id);
	    }
	    catch (e) {
	        // Ignore error if schema already exist
	        if (!e.message.includes("already exists")) {
	            throw e;
	        }
	    }
	};
	exports.validate = function (document, schema) {
	    // TODO document.schema is set as mandatory here because for the moment it can't be made required in the interface
	    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
	    var result = schema ? ajv$1.validate(schema, privacy$1.getData(document)) : ajv$1.validate(document.schema, privacy$1.getData(document));
	    // eslint-disable-next-line no-console
	    // console.log(ajv.errors); // TODO: properly feedback error
	    return result;
	};
	});

	unwrapExports(schema);
	var schema_1 = schema.addSchema;
	var schema_2 = schema.validate;

	var schema$1 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(schema);
	});

	unwrapExports(schema$1);

	var merkle = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });

	function getNextLayer(elements) {
	    return elements.reduce(function (layer, element, index, arr) {
	        if (index % 2 === 0) {
	            // only calculate hash for even indexes
	            layer.push(utils$1.combineHashBuffers(element, arr[index + 1]));
	        }
	        return layer;
	    }, []);
	}
	/**
	 * This function produces the hashes and the merkle tree
	 * If there are no elements, return empty array of array
	 */
	function getLayers(elements) {
	    if (elements.length === 0) {
	        return [[]];
	    }
	    var layers = [];
	    layers.push(elements);
	    while (layers[layers.length - 1].length > 1) {
	        layers.push(getNextLayer(layers[layers.length - 1]));
	    }
	    return layers;
	}
	/**
	 * This function takes a given index and determines if it is the first or second element in a pair, then returns the first element of the pair
	 * If the given index is the last element in a layer with an odd number of elements, then null is returned
	 * E.g 1:
	 *
	 * layer = [ A, B, C, D ],
	 * if index = 2, then return A
	 * if index = 3, then return C
	 *
	 * E.g 2:
	 *
	 * layer = [ A, B, C, D, E]
	 * if index = 5, then return null
	 * if index = 4, then return C
	 */
	function getPair(index, layer) {
	    var pairIndex = index % 2 ? index - 1 : index + 1; // if odd return the index before it, else if even return the index after it
	    if (pairIndex < layer.length) {
	        return layer[pairIndex];
	    }
	    return null; // this happens when the given index is the last element in a layer with odd number of elements
	}
	/**
	 * Finds all the "uncle" nodes required to prove a given element in the merkle tree
	 */
	function getProof(index, layers) {
	    var i = index;
	    var proof = layers.reduce(function (current, layer) {
	        var pair = getPair(i, layer);
	        if (pair) {
	            current.push(pair);
	        }
	        i = Math.floor(i / 2); // finds the index of the parent of the current node
	        return current;
	    }, []);
	    return proof;
	}
	var MerkleTree = /** @class */ (function () {
	    function MerkleTree(_elements) {
	        this.elements = utils$1.hashArray(_elements);
	        // check buffers
	        if (this.elements.some(function (e) { return !(e.length === 32 && Buffer.isBuffer(e)); })) {
	            throw new Error("elements must be 32 byte buffers");
	        }
	        this.layers = getLayers(this.elements);
	    }
	    MerkleTree.prototype.getRoot = function () {
	        return this.layers[this.layers.length - 1][0];
	    };
	    MerkleTree.prototype.getProof = function (_element) {
	        var element = utils$1.toBuffer(_element);
	        var index = this.elements.findIndex(function (e) { return e.equals(element); }); // searches for given element in the merkle tree and returns the index
	        if (index === -1) {
	            throw new Error("Element not found");
	        }
	        return getProof(index, this.layers);
	    };
	    return MerkleTree;
	}());
	exports.MerkleTree = MerkleTree;
	/**
	 * Function that runs through the supplied hashes to arrive at the supplied merkle root hash
	 * @param _proof The list of uncle hashes required to arrive at the supplied merkle root
	 * @param _root The merkle root
	 * @param _element The leaf node that is being verified
	 */
	exports.checkProof = function (_proof, _root, _element) {
	    var proof = _proof.map(function (step) { return utils$1.hashToBuffer(step); });
	    var root = utils$1.hashToBuffer(_root);
	    var element = utils$1.hashToBuffer(_element);
	    var proofRoot = proof.reduce(function (hash, pair) { return utils$1.combineHashBuffers(hash, pair); }, element);
	    return root.equals(proofRoot);
	};
	});

	unwrapExports(merkle);
	var merkle_1 = merkle.MerkleTree;
	var merkle_2 = merkle.checkProof;

	var merkle$1 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(merkle);
	});

	unwrapExports(merkle$1);

	var signature = createCommonjsModule(function (module, exports) {
	var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
	    __assign = Object.assign || function(t) {
	        for (var s, i = 1, n = arguments.length; i < n; i++) {
	            s = arguments[i];
	            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
	                t[p] = s[p];
	        }
	        return t;
	    };
	    return __assign.apply(this, arguments);
	};
	Object.defineProperty(exports, "__esModule", { value: true });





	exports.sign = function (document, batch) {
	    var digest = digest$1.digestDocument(document);
	    if (batch && !batch.includes(digest)) {
	        throw new Error("Document is not in batch");
	    }
	    var batchBuffers = (batch || [digest]).map(utils$1.hashToBuffer);
	    var merkleTree = new merkle$1.MerkleTree(batchBuffers);
	    var merkleRoot = merkleTree.getRoot().toString("hex");
	    var merkleProof = merkleTree.getProof(utils$1.hashToBuffer(digest)).map(function (buffer) { return buffer.toString("hex"); });
	    var signature = {
	        type: "SHA3MerkleProof",
	        targetHash: digest,
	        proof: merkleProof,
	        merkleRoot: merkleRoot
	    };
	    return __assign({}, document, { signature: signature });
	};
	exports.verify = function (document) {
	    var signature = lodash.get(document, "signature");
	    if (!signature) {
	        return false;
	    }
	    // Checks target hash
	    var digest = digest$1.digestDocument(document);
	    var targetHash = lodash.get(document, "signature.targetHash");
	    if (digest !== targetHash)
	        return false;
	    // Calculates merkle root from target hash and proof, then compare to merkle root in document
	    var merkleRoot = lodash.get(document, "signature.merkleRoot");
	    var proof = lodash.get(document, "signature.proof", []);
	    var calculatedMerkleRoot = proof.reduce(function (prev, current) {
	        var prevAsBuffer = utils$1.hashToBuffer(prev);
	        var currAsBuffer = utils$1.hashToBuffer(current);
	        var combineAsBuffer = utils$1.bufSortJoin(prevAsBuffer, currAsBuffer);
	        return jsSha3.keccak256(combineAsBuffer);
	    }, digest);
	    return calculatedMerkleRoot === merkleRoot;
	};
	});

	unwrapExports(signature);
	var signature_1 = signature.sign;
	var signature_2 = signature.verify;

	var signature$1 = createCommonjsModule(function (module, exports) {
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	Object.defineProperty(exports, "__esModule", { value: true });
	__export(signature);
	__export(merkle$1);
	});

	unwrapExports(signature$1);

	var cjs = createCommonjsModule(function (module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });






	exports.utils = utils$1;
	var createDocument = function (data, schema) {
	    var document = privacy$1.setData({ schema: schema.$id, data: null }, salt$1.saltData(data));
	    var valid = schema$1.validate(document, schema);
	    if (valid) {
	        return document;
	    }
	    throw new Error("Invalid document:" + JSON.stringify(data, null, 2));
	};
	exports.issueDocument = function (data, schema) {
	    var document = createDocument(data, schema);
	    return signature$1.sign(document, [digest$1.digestDocument(document)]);
	};
	exports.issueDocuments = function (dataArray, schema) {
	    var documents = dataArray.map(function (data) { return createDocument(data, schema); });
	    var batchHashes = documents.map(digest$1.digestDocument);
	    return documents.map(function (doc) { return signature$1.sign(doc, batchHashes); });
	};
	var digest_2 = digest$1;
	exports.digestDocument = digest_2.digestDocument;
	var privacy_2 = privacy$1;
	exports.getData = privacy_2.getData;
	exports.obfuscateDocument = privacy_2.obfuscateDocument;
	var schema_2 = schema$1;
	exports.addSchema = schema_2.addSchema;
	exports.validateSchema = schema_2.validate;
	var signature_2 = signature$1;
	exports.checkProof = signature_2.checkProof;
	exports.MerkleTree = signature_2.MerkleTree;
	exports.sign = signature_2.sign;
	exports.verifySignature = signature_2.verify;
	});

	var index = unwrapExports(cjs);
	var cjs_1 = cjs.utils;
	var cjs_2 = cjs.issueDocument;
	var cjs_3 = cjs.issueDocuments;
	var cjs_4 = cjs.digestDocument;
	var cjs_5 = cjs.getData;
	var cjs_6 = cjs.obfuscateDocument;
	var cjs_7 = cjs.addSchema;
	var cjs_8 = cjs.validateSchema;
	var cjs_9 = cjs.checkProof;
	var cjs_10 = cjs.MerkleTree;
	var cjs_11 = cjs.sign;
	var cjs_12 = cjs.verifySignature;

	exports.MerkleTree = cjs_10;
	exports.addSchema = cjs_7;
	exports.checkProof = cjs_9;
	exports.default = index;
	exports.digestDocument = cjs_4;
	exports.getData = cjs_5;
	exports.issueDocument = cjs_2;
	exports.issueDocuments = cjs_3;
	exports.obfuscateDocument = cjs_6;
	exports.sign = cjs_11;
	exports.utils = cjs_1;
	exports.validateSchema = cjs_8;
	exports.verifySignature = cjs_12;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
